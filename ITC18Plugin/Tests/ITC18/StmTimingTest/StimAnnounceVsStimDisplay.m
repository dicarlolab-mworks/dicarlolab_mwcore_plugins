function StimAnnounceVsStimDisplay(mwk_file_path, baselinePhotodiodeValue)

addpath('/Library/Application Support/MWorks/Scripting/Matlab')
% this analysis tool is intended to be used with the experiment named
% StmTimingTest.xml in the folder "ABatteryOfBasicTests"

% A phododiode needs to be plugged into ITC analog channel 0 and the
% vertical refresh of the monitor should be plugged into ITC TTL channel 0

% baselinePhotodiodeValue is a value between the base line of the photodiode
% (when the screen is black) and the lower bound of the photodiode's
% signal.  This is used to determine when the stimulus is turned on and
% off.

% to run the test, load the test into the server (the following code
% assumes that it was started and run from the client).  Save a data file
% and use tools to convert it to a MATLAB struct.  Pass the MATLAB struct 
% (usually called 'events') to this function along with the 
% baselinePhotodiodeValue.  This value is dependent on the disance the
% photodiode is to the screen, the ambient light in the room, etc.
% Genreally a value of 0.06-0.08 V is adequate.

% This function generates histograms the display delays experienced in the 
% stim display.  The first plot shows the delay between the event
% #stimDisplayUpdate and the actual screen refresh retained from the
% photodiode.  Plot 2 is the time between #stimDisplayUpdate and the next
% vertical refresh.

% Plot 3 is generated by recording the time of a variable assignment action
% directly before an update_stimulus_display action, and the time elapsed
% before #stimDisplayUpdate is announced.  Plot 4 is the same except it is
% the delay until the screen is actually refreshed.

% Figure 2 is the 

% Find codes of relevant variables

codecs=getCodecs(mwk_file_path);

codec = struct2cell(codecs(1).codec);
codec = codec(1:2,:);
code.announcestim = codec{1,find(strcmp('#announceStimulus',codec(2,:)))};
code.stimDisplayUpdate = codec{1,find(strcmp('#stimDisplayUpdate',codec(2,:)))};
code.beampos = codec{1,find(strcmp('#beamPosition',codec(2,:)))};
code.luminence = codec{1,find(strcmp('luminence',codec(2,:)))};
code.vertical_refresh = codec{1,find(strcmp('vertical_refresh',codec(2,:)))};
code.display_update = codec{1,find(strcmp('display_update',codec(2,:)))};
code.task_mode = codec{1,find(strcmp('#task_mode',codec(2,:)))};

% get a starting time
tm=getEvents(mwk_file_path, code.task_mode);
starting_time = tm(find([tm.data] == 2, 1)).time_us;

% Get all the luminence events
lumevents = getEvents(mwk_file_path, code.luminence, starting_time);
%lumevents = getEvents(mwk_file_path, code.luminence, starting_time, starting_time + 100000000);
luminencetimes = [lumevents.time_us];
lumrisers = luminencetimes(find(diff(find([lumevents.data] > 0.05)) > 1));


% Get all the vertical_refresh events
vrevents = getEvents(mwk_file_path, code.vertical_refresh);
%vrevents = getEvents(mwk_file_path, code.vertical_refresh, starting_time, starting_time + 100000000);
vrtimes = [vrevents.time_us];

% Get all the #announceStimulus events
stimevents = getEvents(mwk_file_path, code.announcestim);
%stimevents = getEvents(mwk_file_path, code.announcestim, starting_time, starting_time + 100000000);
stimtimes = [stimevents.time_us];


% Get all the #stimDisplayUpdate events
updateevents = getEvents(mwk_file_path, code.stimDisplayUpdate);
%updateevents = getEvents(mwk_file_path, code.stimDisplayUpdate, starting_time, starting_time + 100000000);
updatetimes = [updateevents.time_us];

% Get all the display_update events
duevents = getEvents(mwk_file_path, code.display_update, starting_time);
%duevents = getEvents(mwk_file_path, code.display_update, starting_time, starting_time + 100000000);
dutimes = [duevents.time_us];

% Get all the #beamPosition events
beamevents = getEvents(mwk_file_path, code.beampos);
%beamevents = getEvents(mwk_file_path, code.beampos, starting_time, starting_time + 100000000);
beamtimes = [beamevents.time_us];

a = find([lumevents.data] > baselinePhotodiodeValue);
temp = zeros(size(luminencetimes));
temp(a) = 1;
lumincence_change_idx = find(abs(diff(temp)) > 0);

delayBetweenStimDisplayUpdateAndActualUpdate = [];
for i = 1:size(updatetimes,2)
    idx = find(luminencetimes(lumincence_change_idx) > updatetimes(i));
    if(size(idx) > 0)
        delayBetweenStimDisplayUpdateAndActualUpdate = [delayBetweenStimDisplayUpdateAndActualUpdate luminencetimes(lumincence_change_idx(idx(1)))-updatetimes(i)];
    end
end

delayBetweenStimDisplayUpdateAndNextVerticalRefresh = [];
for i = 1:size(updatetimes,2)
    idx = find(vrtimes > updatetimes(i));
    if(size(idx) > 0)
        delayBetweenStimDisplayUpdateAndNextVerticalRefresh = [delayBetweenStimDisplayUpdateAndNextVerticalRefresh vrtimes(idx(1))-updatetimes(i)];
    end
end

delayBetweenUpdateDisplayIncrementAndStimDisplayUpdate = [];
for i = 1:size(dutimes,2)
    idx = find(updatetimes > dutimes(i));
    if(size(idx) > 0)
        delayBetweenUpdateDisplayIncrementAndStimDisplayUpdate = [delayBetweenUpdateDisplayIncrementAndStimDisplayUpdate updatetimes(idx(1))-dutimes(i)];
    end
end

delayBetweenUpdateDisplayIncrementAndActualUpdate = [];
for i = 1:size(dutimes,2)
    idx = find(luminencetimes(lumincence_change_idx) > dutimes(i));
    if(size(idx) > 0)
        delayBetweenUpdateDisplayIncrementAndActualUpdate = [delayBetweenUpdateDisplayIncrementAndActualUpdate luminencetimes(lumincence_change_idx(idx(1)))-dutimes(i)];
    end
end

% the first two data points are not relevant because they are the announces
% connecting the data file and at the start of the experiment...there would
% be one more irrelavent point if there was a client connected also
figure(1);
subplot(2,2,1);
hist(delayBetweenStimDisplayUpdateAndActualUpdate(12:end-12)./1000,[0:0.5:30]);
title('delay between #stimDisplayUpdate and actual screen refresh');
xlabel('ms')
subplot(2,2,2);
hist(delayBetweenStimDisplayUpdateAndNextVerticalRefresh(12:end-12)./1000,[0:0.5:30]);
title('delay between #stimDisplayUpdate and next vertical refresh');
xlabel('ms')
subplot(2,2,3);
hist(delayBetweenUpdateDisplayIncrementAndStimDisplayUpdate(12:end-12)./1000,[0:0.5:30]);
title('delay between display refresh action and #stimDisplayUpdate');
xlabel('ms')
subplot(2,2,4);
hist(delayBetweenUpdateDisplayIncrementAndActualUpdate(12:end-12)./1000,[0:0.5:30]);
title('delay between display refresh action and actual screen refresh');
xlabel('ms')

figure(2);
plot(luminencetimes, [lumevents.data], 'b-');
hold on;
%plot(beamtimes, [beamevents.data], 'b-');
plot(vrtimes, ones(size(vrtimes)).*0.051, 'k*', 'MarkerSize',[2]);
plot(updatetimes, ones(size(updatetimes)).*0.05, 'g*', 'MarkerSize',[2]);
plot(luminencetimes(find(abs(diff(temp)) > 0)), ones(size(luminencetimes(find(abs(diff(temp)) > 0)))).*0.049, 'r*')
title('events transpired');
xlabel('us')
hold off;




